---
import type { HTMLAttributes } from 'astro/types';
import type { ImageMetadata } from 'astro';
import PauseIcon from '@assets/icons/pause.svg';
import PlayIcon from '@assets/icons/play.svg';

interface Props extends Omit<HTMLAttributes<'img'>, 'src'> {
  src: ImageMetadata;
  alt: string;
}

const { src, alt, ...rest } = Astro.props as Props;
// A per-component unique id so multiple LoopingImage instances can coexist safely
const uid = globalThis.crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2);

// Get image dimensions for placeholder
const width = src.width;
const height = src.height;
---

<div class="looping-image-wrapper not-content" data-looping-image-id={uid}>
  <img
    class="looping-image-placeholder"
    data-looping-image-id={uid}
    data-width={width}
    data-height={height}
    alt=""
    aria-hidden="true"
    width={width}
    height={height}
  />
  <img
    class="looping-image"
    src={src.src}
    alt={alt}
    data-looping-image-id={uid}
    width={width}
    height={height}
    {...rest}
  />
  <canvas
    class="looping-image-canvas not-content"
    data-looping-image-id={uid}
    style="display: none;"></canvas>
  <button
    type="button"
    class="looping-image-toggle"
    aria-label="Pause animation"
    data-state="playing"
    data-looping-image-id={uid}
    style="display: none;"
  >
    <span class="icon icon-pause" aria-hidden="true"><PauseIcon width="80" height="80" /></span>
    <span class="icon icon-play" aria-hidden="true"><PlayIcon width="80" height="80" /></span>
    <span class="sr-only">Pause animation</span>
  </button>
</div>

<script>
  // @ts-nocheck -- Client-side DOM manipulation with runtime casts; suppress to avoid implicit any noise.

  function getCurrentTheme() {
    const html = document.documentElement;
    return html.getAttribute('data-theme') || 'light';
  }

  function getPlaceholderUrl(width, height, theme) {
    // Theme-specific colors
    const colors = {
      light: {
        bg: 'edf2f7',
        text: '1a202c',
      },
      dark: {
        bg: '1e2024',
        text: 'e4e7eb',
      },
    };

    const themeColors = colors[theme] || colors.light;
    return `https://placehold.co/${width}x${height}/${themeColors.bg}/${themeColors.text}.png?text=Loading...%20please%20wait.&font=Poppins`;
  }

  function updatePlaceholderForTheme(placeholder) {
    if (!(placeholder instanceof HTMLImageElement)) return;
    const width = placeholder.getAttribute('data-width');
    const height = placeholder.getAttribute('data-height');
    if (!width || !height) return;

    const theme = getCurrentTheme();
    placeholder.src = getPlaceholderUrl(width, height, theme);
  }

  function initButtons() {
    const prefersNoHover = window.matchMedia && window.matchMedia('(hover: none)').matches;

    document.querySelectorAll('.looping-image-wrapper').forEach((wrapper) => {
      const img = wrapper.querySelector('img.looping-image');
      const placeholder = wrapper.querySelector('.looping-image-placeholder');
      const canvas = wrapper.querySelector('canvas.looping-image-canvas');
      const btn = wrapper.querySelector('.looping-image-toggle');

      if (
        !(img instanceof HTMLImageElement) ||
        !(placeholder instanceof HTMLElement) ||
        !(canvas instanceof HTMLCanvasElement) ||
        !(btn instanceof HTMLButtonElement)
      )
        return;

      // Set initial placeholder URL based on current theme
      updatePlaceholderForTheme(placeholder);

      const srOnly = btn.querySelector('.sr-only');
      let isPlaying = true;
      let staticImageData = null;
      let isLoaded = false;

      // Handle image load
      function onImageLoad() {
        if (isLoaded) return;
        isLoaded = true;

        // Fade in the actual image
        img.style.opacity = '1';
        btn.style.display = 'flex';

        // After fade completes, hide placeholder
        setTimeout(() => {
          placeholder.style.display = 'none';
        }, 300);
      }

      // Capture a static frame from the GIF for the paused state
      function captureStaticFrame() {
        if (staticImageData) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Set canvas size to match image
        canvas.width = img.naturalWidth || img.width;
        canvas.height = img.naturalHeight || img.height;

        // Draw current frame
        ctx.drawImage(img, 0, 0);
        staticImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }

      function syncButton() {
        btn.dataset.state = isPlaying ? 'playing' : 'paused';
        btn.setAttribute('aria-label', isPlaying ? 'Pause animation' : 'Play animation');
        if (srOnly) srOnly.textContent = isPlaying ? 'Pause animation' : 'Play animation';
      }

      let hideTimer = null;
      function showButtonTransient() {
        if (!isLoaded) return; // Don't show button until loaded

        // Show (or keep) button visible briefly after interaction on all devices
        btn.classList.add('force-visible');
        if (hideTimer) clearTimeout(hideTimer);
        hideTimer = setTimeout(() => {
          btn.classList.remove('force-visible');
          // Blur to prevent lingering focus style for mouse users
          if (!prefersNoHover && document.activeElement === btn) {
            btn.blur();
          }
        }, 1500);
      }

      function togglePlayback() {
        if (!isLoaded) return; // Don't allow toggle until loaded

        if (isPlaying) {
          // Pause: capture current frame and show it on canvas
          captureStaticFrame();
          if (staticImageData) {
            const ctx = canvas.getContext('2d');
            if (ctx) {
              ctx.putImageData(staticImageData, 0, 0);
              img.style.opacity = '0';
              canvas.style.display = 'block';
              canvas.style.opacity = '1';
            }
          }
          isPlaying = false;
        } else {
          // Play: fade out canvas first, then restart GIF
          canvas.style.opacity = '0';

          setTimeout(() => {
            canvas.style.display = 'none';
            img.style.opacity = '1';
            // Force browser to restart the GIF animation
            const src = img.src;
            img.src = '';
            img.src = src;
          }, 150); // Wait for canvas fade out

          isPlaying = true;
        }
        syncButton();
        showButtonTransient();
      }

      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        togglePlayback();
      });

      if (prefersNoHover) {
        // Tap anywhere on image to toggle on mobile-like devices
        wrapper.addEventListener('click', (e) => {
          if (e.target === btn || btn.contains(e.target)) return;
          togglePlayback();
        });
      }

      // Wait for image to load before showing it
      if (img.complete && img.naturalWidth > 0) {
        // Image already loaded
        onImageLoad();
      } else {
        img.addEventListener('load', onImageLoad);
        // Handle load errors
        img.addEventListener('error', () => {
          console.error('Failed to load image:', img.src);
          // Hide placeholder on error
          placeholder.style.display = 'none';
        });
      }

      syncButton();
    });
  }

  function initLoopingImages() {
    try {
      initButtons();

      // Watch for theme changes
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (
            mutation.type === 'attributes' &&
            mutation.attributeName === 'data-theme' &&
            mutation.target === document.documentElement
          ) {
            // Update all placeholders when theme changes
            document
              .querySelectorAll('.looping-image-placeholder')
              .forEach((placeholder) => updatePlaceholderForTheme(placeholder));
          }
        }
      });
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-theme'],
      });
    } catch (error) {
      console.error('Failed to initialize looping images:', error);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initLoopingImages);
  } else {
    initLoopingImages();
  }
</script>

<style>
  .looping-image-wrapper {
    position: relative;
    display: inline-block;
  }

  img.looping-image,
  img.looping-image-placeholder,
  canvas.looping-image-canvas {
    border-radius: 0.5rem;
    border: 1px solid var(--sl-color-gray-5);
    box-shadow: var(--sl-shadow-lg);
    height: auto;
    max-width: 100%;
    display: block;
  }

  img.looping-image {
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }

  canvas.looping-image-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: contain;
    display: none;
    opacity: 0;
    transition: opacity 0.15s ease-in-out;
  }

  .looping-image-toggle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid var(--sl-color-gray-4);
    border-radius: 0.5rem;
    cursor: pointer;
    padding: 0;
    color: var(---aspire-color-primary, #6d4aff);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease;
  }

  html[data-theme='dark'] .looping-image-toggle {
    background: var(--aspire-color-secondary);
    background: color-mix(in srgb, var(--aspire-color-secondary) 20%, transparent);
    color: var(--aspire-color-secondary);
    border: 1px solid var(--sl-color-gray-3);
  }

  .looping-image-toggle:focus-visible {
    outline: 2px solid var(--aspire-color-primary, #6d4aff);
    outline-offset: 4px;
    opacity: 1;
    pointer-events: auto;
  }

  /* Show button on hover for devices that support hover */
  @media (hover: hover) {
    .looping-image-wrapper:hover .looping-image-toggle {
      opacity: 1;
      pointer-events: auto;
    }
  }

  /* Mobile / touch: smaller, only when force-visible (after interaction) */
  @media (hover: none) {
    .looping-image-toggle {
      width: 3rem; /* slightly larger but still compact on mobile */
      height: 3rem;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--sl-color-gray-5);
      border-radius: 0.5rem;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }
    .looping-image-toggle .icon svg {
      width: 28px;
      height: 28px;
    }
  }

  .looping-image-toggle.force-visible {
    opacity: 1;
    pointer-events: auto;
  }

  .looping-image-toggle .icon {
    line-height: 0;
    display: inline-block;
  }

  .looping-image-toggle .icon-play {
    display: none;
  }
  .looping-image-toggle[data-state='paused'] .icon-pause {
    display: none;
  }
  .looping-image-toggle[data-state='paused'] .icon-play {
    display: inline-block;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>
